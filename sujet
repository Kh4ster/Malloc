A ALLER LIRE :
stdint.h
pthead.h
mman.h
ptreah.h
their given files

 - Base features :
void *malloc(size_t size);
void free(void *ptr);
void *calloc(size_t number, size_t size);
void *realloc(void *ptr, size_t size);
-> mettre de base tout même si pas de code mais rien d'autre

malloc :
alloue bloc taille n return null sinon (si taille = 0)
free :
if null nothing, else realease memory
-> protéger contre garbage data en metatnt des 0 avant et après
calloc :
same as malloc just memset 0
realloc :


Avdanced :
-> reduce frag using algos
-> realloc extend current memory if can rather than new
-> realloc works even with alot of calls
-> speed (algo + thread) -> speed.py
-> limit memap calls -> memorfootpint -> see page 11
-> compiling projet with own malloc
-> thread-safe malloc -> detail p 12
-> realworld allocator -> detail p 12

-> que si tout tout fini -> corruption proof -> detail p 13


 !! A LIRE AVANT DE CODER !!
- Concret code :

-> Peut 5 cast explicite, sinon implicite
-> Avoir direct un algo efficace et peut de place mémoire
-> Direct thread safe
-> mmap(null, size, RW, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0) != MAP_FAILED
-> utiliser une variable globale
-> cast implicite 
-> struct meta *m = ptr; m--; munmap(m, m->size)
-> doublement chaînées la liste de page
-> pas oublier memeset, memecpy

Exo :
-> overflow -> pour calloc
-> page begin -> pour un poiteur donné, trouver debut de la page

Structure :
-> feuille


- Compilation :

-> utiliser leur makefile
-> utiliser  nm -C -D libmalloc.so
-> faut que eux et pas plus

- Question :
A quoi servent les fichiers call_trace.c et malloc.c ?

- Test

-> utiliser leurs fichiers
-> aller voir la partie linkage p6/7
• factor 20 30 40 50 60 70 80 90
• cat Makefile
• ip a
• ls
• ls -la
• tar -cf malloc.tar libmalloc.so
• find /
• tree /
• od libmalloc.so
git status
• less Makefile
• clang -h
multi thread
• gimp
• chromium-browser